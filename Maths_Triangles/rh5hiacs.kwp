#include "MyWindow.h"

int window_init()
{
	std::cout << "OpenGL Version " << glGetString(GL_VERSION) << std::endl;
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

	openGLWindow = glfwCreateWindow(800, 600, "LearnOpenGL", nullptr, nullptr);
	if (openGLWindow == nullptr)
	{
		std::cout << "Failed to create GLFW window" << std::endl;
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(openGLWindow); 
	glewExperimental = GL_TRUE;
	if (glewInit() != GLEW_OK)
	{
		std::cout << "Failed to initialize GLEW" << std::endl;
		return -1;
	}

	glViewport(0, 0, 800, 600);
	glOrtho(0.0, 800.0, 600.0, 0.0);
	glfwSetKeyCallback(openGLWindow, window_keyPressed);
	return 0;
}


int window_mainLoop(GLFWwindow* openGLWindow)
{

	// Build and compile our shader program
	// Vertex shader
	GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
	glCompileShader(vertexShader);
	// Check for compile time errors
	GLint success;
	GLchar infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
	if (!success)
	{
		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
		std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
	}
	// Fragment shader
	GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
	glCompileShader(fragmentShader);
	// Check for compile time errors
	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
	if (!success)
	{
		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
		std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
	}
	// Link shaders
	GLuint shaderProgram = glCreateProgram();
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	glLinkProgram(shaderProgram);
	// Check for linking errors
	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
	if (!success) {
		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
		std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
	}
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);

	GLuint VAO;
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);
	// Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).
	glBindVertexArray(VAO);
    
    updateGraphics();

	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
	glEnableVertexAttribArray(0);

	glBindBuffer(GL_ARRAY_BUFFER, 0); // Note that this is allowed, the call to glVertexAttribPointer registered VBO as the currently bound vertex buffer object so afterwards we can safely unbind

	glBindVertexArray(0); // Unbind VAO (it's always a good thing to unbind any buffer/array to prevent strange bugs), remember: do NOT unbind the EBO, keep it bound to this VAO



	while (!glfwWindowShouldClose(openGLWindow))
	{
		glfwPollEvents();
		glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
		glClear(GL_COLOR_BUFFER_BIT);
        glUseProgram(shaderProgram);
        glBindVertexArray(VAO);
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
		glfwSwapBuffers(openGLWindow);
	}

	glDeleteVertexArrays(1, &VAO);
	glDeleteBuffers(1, &VBO);
	glDeleteBuffers(1, &EBO);
	glfwTerminate();
	return 0;
}

void window_updateGraphics()
{
	int indicesSize = scene.getIndicesSize();
	int verticesSize = scene.getVerticesSize();
	GLfloat* vertices = (GLfloat*)malloc(sizeof(GLfloat)* verticesSize);
	GLuint* indices = (GLuint*)malloc(sizeof(GLuint)* indicesSize);
	int index = 0;
	scene.getVertices(vertices, &index);
	for (int i = 0; i < indicesSize; i++)
	{
		indices[i] = i;
	}
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, verticesSize * sizeof(GLfloat), vertices, GL_STATIC_DRAW);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesSize * sizeof(GLuint), indices, GL_STATIC_DRAW);
}

void window_onclick(GLFWwindow* activeWindow, float x, float y)
{
    Point p = Point(x, y);
    if(!p1)
    {
        p1 = std::shared_ptr<Point>(&p);
        points.push_back(p1);
    }
    else if(!p2)
    {
		p2 = std::shared_ptr<Point>(&p);
        points.push_back(p2);
    }
    else
    {
		std::shared_ptr<Point> p3 = std::shared_ptr<Point>(&p);
		Triangle t = Triangle(p1, p2, p3);
		(*o).addTriangle(std::unique_ptr<Triangle>(&t));
        points.push_back(p3);
        p1 = p2 = p3 = nullptr;
    }
    window_updateGraphics();
}



void window_keyPressed(GLFWwindow* activeWindow, int key, int scancode, int action, int mode)
{
	// When a user presses the escape key, we set the WindowShouldClose property to true, 
	// closing the application
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(activeWindow, GL_TRUE);
	if (key == GLFW_KEY_N && action == GLFW_PRESS)
    {
        scene.addObject(o);
		o = std::unique_ptr<Object>(new Object());
        window_updateGraphics();
    }
    
    
}

int main()
{
	scene = Scene();
	Object object = Object();
	Triangle triangle = Triangle(std::shared_ptr<Point>(new Point(0.5f, 0.5f)), std::shared_ptr<Point>(new Point(0.5f, -0.5f)), std::shared_ptr<Point>(new Point(-0.5f, 0.5f)));
	object.addTriangle(std::unique_ptr<Triangle>(&triangle));
	scene.addObject(std::unique_ptr<Object>(&object));
	int r = window_init();
	if (r < 0)
		return r;
	else
		return window_mainLoop(openGLWindow);
	return 0;
}